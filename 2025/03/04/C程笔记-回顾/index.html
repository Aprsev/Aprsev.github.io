<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C程笔记&amp;回顾 | Aprsev house</title><meta name="author" content="Aprsev Xu"><meta name="copyright" content="Aprsev Xu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="C程复习第一章 什么是C语言 第一章内容更多的是对C语言的基本语法和程序学习相关基础知识的总述，其中会涉及到函数，ADT等内容，这里只是做一个基础认识，后续章节会有更加详细的表述和代码示例。:kiss  C程序是由函数所组成的。 程序和数据一样，共同存放在存储器中。当程序要运行时，当前准备运行的指令从内存被调入CPU中，由CPU处理该条指令。这种将程序和数据共同存储的思想是冯·诺依曼模型的存储程序">
<meta property="og:type" content="article">
<meta property="og:title" content="C程笔记&amp;回顾">
<meta property="og:url" content="http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/index.html">
<meta property="og:site_name" content="Aprsev house">
<meta property="og:description" content="C程复习第一章 什么是C语言 第一章内容更多的是对C语言的基本语法和程序学习相关基础知识的总述，其中会涉及到函数，ADT等内容，这里只是做一个基础认识，后续章节会有更加详细的表述和代码示例。:kiss  C程序是由函数所组成的。 程序和数据一样，共同存放在存储器中。当程序要运行时，当前准备运行的指令从内存被调入CPU中，由CPU处理该条指令。这种将程序和数据共同存储的思想是冯·诺依曼模型的存储程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/C.jpg">
<meta property="article:published_time" content="2025-03-04T01:20:06.000Z">
<meta property="article:modified_time" content="2025-03-04T04:14:22.656Z">
<meta property="article:author" content="Aprsev Xu">
<meta property="article:tag" content="C">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/C.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C程笔记&回顾",
  "url": "http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/",
  "image": "http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/C.jpg",
  "datePublished": "2025-03-04T01:20:06.000Z",
  "dateModified": "2025-03-04T04:14:22.656Z",
  "author": [
    {
      "@type": "Person",
      "name": "Aprsev Xu",
      "url": "http://aprsev.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="../../../../pic/nav-logo.png"><link rel="canonical" href="http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="../../../../css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C程笔记&回顾',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/pic/cover.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../pic/head.png" onerror="this.onerror=null;this.src='../img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="../archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="../tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="../tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="../categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="../movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="../link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(2025/03/04/C程笔记-回顾/C.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="../../../../index.html"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../../../pic/nav-logo.png" alt="Logo"><span class="site-name">Aprsev house</span></a><a class="nav-page-title" href="../../../../index.html"><span class="site-name">C程笔记&amp;回顾</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="../index.html"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="../archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="../tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="../categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="../music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="../movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="../link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="../about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C程笔记&amp;回顾</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-04T01:20:06.000Z" title="发表于 2025-03-04 09:20:06">2025-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T04:14:22.656Z" title="更新于 2025-03-04 12:14:22">2025-03-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C程复习"><a href="#C程复习" class="headerlink" title="C程复习"></a>C程复习</h1><h2 id="第一章-什么是C语言"><a href="#第一章-什么是C语言" class="headerlink" title="第一章 什么是C语言"></a>第一章 什么是C语言</h2><blockquote>
<p>第一章内容更多的是对C语言的基本语法和程序学习相关基础知识的总述，其中会涉及到函数，ADT等内容，这里只是做一个基础认识，后续章节会有更加详细的表述和代码示例。:kiss</p>
</blockquote>
<p>C程序是由<strong>函数</strong>所组成的。</p>
<p>程序和数据一样，共同存放在存储器中。当程序要运行时，当前准备运行的指令从内存被调入CPU中，由CPU处理该条指令。这种将程序和数据共同存储的思想是<strong>冯·诺依曼模型</strong>的存储程序概念。</p>
<blockquote>
<p>指令部分主要涉及汇编，C程要求了解即可：<br>	指令作为最基础的计算机处理单元，一般由多个指令组合实现计算机的复杂功能<br>	一般程序会经过编译器（也就是C程要求的DevC++，vscode等）编译成电脑可执行的二进制文件，其中内容为顺序排列的指令码</p>
</blockquote>
<h3 id="程序设计语言"><a href="#程序设计语言" class="headerlink" title="程序设计语言"></a>程序设计语言</h3><ol>
<li>数据表达<ul>
<li><p>数据类型（data type）：对某种具有共同特征的数据<strong>集合</strong>的总称</p>
<ul>
<li>代表什么数据</li>
<li>可以对数据进行什么操作（运算）</li>
<li>常见数据类型：<ul>
<li><p>整形：整数变量</p>
</li>
<li><p>实型（浮点型）：小数变量</p>
<blockquote>
<p>1 和1.0在计算机语言中一般不同，主要体现在数据类型导致的存储结构不同</p>
</blockquote>
</li>
<li><p>字符型：中英文字符内容</p>
</li>
</ul>
</li>
<li>形式：<ul>
<li>常量：表示一些程序运行过程的不变值</li>
<li>变量：可以对其进行相关的操作，改变它的值<blockquote>
<p>这之中的区别在实际代码中个人理解主要体现在后期函数间交流和项目跨代码调用中体现</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象数据类型（abstract data type）：<br>  为了完成程序的相关工作设计的一些复杂的数据类型，如数组，结构，文件，指针等。</p>
</li>
</ul>
</li>
<li>流程控制<br> 程序的运行通常会要求比较复杂的控制过程，因此有必要对程序工作进行结构化设计。<ul>
<li>顺序结构：按照自然顺序执行模块</li>
<li>分支结构：根据设定条件进行判断，然后选择不同的模块进行运行</li>
<li>循环结构：反复执行相同重复的模块的结构<blockquote>
<p>这3中结构是构成一切程序设计语言基本结构</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>主要作用起到程序规范化，使得编译器可以正确识别程序内容，并编译。可以理解为你写的代码只是一串字符的组合，背后有人写好的更底层的代码对你的字符组合进行阅读理解，从而写出计算机可以理解的二进制文件（计算机的直接处理只能为01）。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>由字母、数字和下划线组成，其中<strong>第一个字符必须是字母或下划线</strong>。同时字母的<strong>大小写</strong>是有区别的。</p>
<ul>
<li>保留字（关键字）：C语言规定的、赋予特定含义和有专门用途的标识符，如int,float,if,else等。</li>
<li>用户自定义标识符：变量名、<strong>数据类型名</strong>（结构体属于一种用户自定义的数据类型）、函数名和符号常量</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>常量：即有数据类型的不变量</li>
<li>运算符：表示对各种数据类型对象运算，详见可查看<a href="#chart">附表</a> </li>
<li>分隔符：; ( ) [ ] # 等均为分隔符</li>
</ol>
<h4 id="语法单位"><a href="#语法单位" class="headerlink" title="语法单位"></a>语法单位</h4><ol>
<li>表达式：运算符与运算对象（常量、函数、变量等）的有意义组合</li>
<li>变量定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">char</span> c;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>语句：<strong>程序最基本的执行单位</strong><ul>
<li>表达式语句：表达式加<strong>分号</strong>（分号在C中表示一个表达式语句的结束）</li>
<li>分支语句</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">	x = a;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	x = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>循环语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">	sum = sum + i;</span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>复合语句：用大括号将若干语句顺序组合<blockquote>
<p>在C语言中复合语句的产生主要来自于C语言对于分支语句和循环语句的要求均为仅能包含一个表达式语句，而在大多数情况下这是不够的，因此采用{}包裹的复合语句，在语法上就认定为它是一个表达式语句</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>函数定义与调用：函数主要是对一些重复过程进行打包化处理的工作，在多数情况会极大减少代码体量，且利于修改</li>
<li>输入与输出</li>
<li>命令：include&lt;&gt;</li>
</ol>
<blockquote>
<p>值得强调的是，因为C语言对语句的分割由;或{}判断，本身对缩进没有任何要求，即使你全写在一行里也是可以运行的，但是为了程序调试和结构观察，强烈建议按照一定的缩进格式进行代码撰写，可参考隔壁<a target="_blank" rel="noopener" href="https://blog.csdn.net/YunxiaoYuji1/article/details/130648822">python缩进规范</a></p>
</blockquote>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>对源程序进行词法分析，语法和语义分析，最后生成<strong>可执行文件</strong></p>
<ol>
<li>生成一个二进制代码表示的目标程序（.obj），<strong>这发生在检查语法正确性之后</strong></li>
<li>与编译环境提供的库函数进行连接，形成可执行文件（.exe)</li>
</ol>
<h3 id="C语言特点"><a href="#C语言特点" class="headerlink" title="C语言特点"></a>C语言特点</h3><ol>
<li>结构化语言</li>
<li>语句简洁紧凑，使用方便灵活</li>
<li>易于移植</li>
<li>强大处理能力</li>
<li>生成目标代码质量高、运行效率高</li>
<li><strong>不足</strong><ul>
<li>数据类型检查不严格</li>
<li>表达式出现二义性</li>
<li>不能检查数据越界</li>
<li>初学者难掌握运算符优先级和结合性概念</li>
<li>……</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第二章-if分段与for循环"><a href="#第二章-if分段与for循环" class="headerlink" title="第二章 if分段与for循环"></a>第二章 if分段与for循环</h2><blockquote>
<p>这章就会涉及简单的分支和循环结构，以及C语言程序的代码基本架构，但是，这之中还是会涉及以些深层的本质内容，如main函数等，本章学习要求更多就只需要简单记忆和学会使用if和for语句</p>
</blockquote>
<ol>
<li><p>main函数</p>
<ul>
<li>任何程序有且仅有一个main函数，程序运行首先从main函数开始</li>
<li>从本质上来讲，main就是一个函数，因此它拥有一个函数要求的所有内容</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;                 <span class="comment">/*()中的void表示函数无需参数输入，在进阶使用会改变*/</span></span><br><span class="line">	<span class="comment">/*You should put your code here*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;                  <span class="comment">/*main函数根据定义为int 整型，因此需要return一个整数，通常为0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算数运算和赋值运算<ul>
<li>算数运算：</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">+</th>
<th align="center">-</th>
<th align="center">*</th>
<th align="center">&#x2F;</th>
<th align="center">%</th>
</tr>
</thead>
<tbody><tr>
<td align="center">名称</td>
<td align="center">加</td>
<td align="center">减</td>
<td align="center">乘</td>
<td align="center">（整）除</td>
<td align="center">取模（取余）</td>
</tr>
<tr>
<td align="center">优先级</td>
<td align="center">低</td>
<td align="center">低</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">两个除法操作须注意一下：</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="（除法运算符）"><a href="#（除法运算符）" class="headerlink" title="/（除法运算符）"></a><strong><code>/</code>（除法运算符）</strong></h3><p><code>/</code> 是除法运算符，用于计算两个数的商。它的行为取决于操作数的类型（整数或浮点数）</p>
<h4 id="数据类型要求"><a href="#数据类型要求" class="headerlink" title="数据类型要求"></a><strong>数据类型要求</strong></h4><ul>
<li><strong>操作数</strong>：可以是整数类型（<code>int</code>、<code>long</code>、<code>short</code>、<code>char</code> 等）或浮点数类型（<code>float</code>、<code>double</code>）。</li>
<li><strong>结果</strong>：结果的类型取决于操作数的类型组合。</li>
</ul>
<h4 id="不同数据类型处理"><a href="#不同数据类型处理" class="headerlink" title="不同数据类型处理"></a><strong>不同数据类型处理</strong></h4><ol>
<li><strong>整数除法</strong>：<ul>
<li>如果两个操作数都是整数类型，结果也是整数类型（<code>int</code> 或 <code>long</code>），并且会进行<strong>截断</strong>（丢弃小数部分）。</li>
<li>例如：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result = a / b;  <span class="comment">// result = 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>浮点数除法</strong>：<ul>
<li>如果至少有一个操作数是浮点数类型（<code>float</code> 或 <code>double</code>），结果会是浮点数类型（<code>float</code> 或 <code>double</code>），并且会保留小数部分。</li>
<li>例如：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">float</span> result = a / b;  <span class="comment">// result = 3.333333</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>混合类型除法</strong>：<ul>
<li>如果一个操作数是整数类型，另一个是浮点数类型，整数操作数会被隐式转换为浮点数类型，结果也是浮点数类型。</li>
<li>例如：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.0f</span>;</span><br><span class="line"><span class="type">float</span> result = a / b;  <span class="comment">// result = 3.333333</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-（取模运算符）"><a href="#2-（取模运算符）" class="headerlink" title="2. %（取模运算符）"></a><strong>2. <code>%</code>（取模运算符）</strong></h3><p><code>%</code> 是取模运算符，用于计算两个整数相除后的余数。它只能用于整数类型，不能用于浮点数。</p>
<h4 id="数据类型要求-1"><a href="#数据类型要求-1" class="headerlink" title="数据类型要求"></a><strong>数据类型要求</strong></h4><ul>
<li><strong>操作数</strong>：两个操作数都必须是整数类型（<code>int</code>、<code>long</code>、<code>short</code>、<code>char</code> 等）。</li>
<li><strong>结果</strong>：结果的类型与操作数的类型一致，通常是操作数中较大的类型。</li>
</ul>
<h4 id="不同数据类型处理-1"><a href="#不同数据类型处理-1" class="headerlink" title="不同数据类型处理"></a><strong>不同数据类型处理</strong></h4><ul>
<li>如果操作数是 <code>int</code>，结果也是 <code>int</code>。</li>
<li>如果操作数是 <code>long</code>，结果是 <code>long</code>。</li>
<li>如果操作数是 <code>char</code> 或 <code>short</code>，它们会被隐式提升为 <code>int</code>，结果也是 <code>int</code>。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result = a % b;  <span class="comment">// result = 1</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul>
<li>取模运算符 <code>%</code> 的第二个操作数不能为零，否则会导致运行时错误。</li>
<li>对于负数，取模运算的结果取决于编译器的实现。在 C 语言中，<code>a % b</code> 的结果符号与 <code>a</code> 的符号一致。</li>
</ul>
<hr>
<ol start="3">
<li><p>printf(格式控制字符串，输出参数1，……)</p>
<ul>
<li>%m.nf表示输出<strong>数据宽度为m（包括符号位）（默认向右对齐，若向左则为-m），且保留n位小数</strong>，具体输出使用在<a href="#type-ctl">这里</a></li>
<li>这里补充一个关于printf函数输出原理的链接，主要就是解释了它用的是栈[关于printf输出的奇怪事:printf(“%d %d %d %d %d\n“, ++i, –i, i++,i–, i),printf(“%c%c\n“,*p++,*p++)的结果分析_inti &#x3D; 8; printf(“%d,%d,%d,%dn”,++i,–i,i–,i–)-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43519514/article/details/121842805?ops_request_misc=%7B%22request_id%22:%22170438093616800222836666%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170438093616800222836666&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-121842805-null-null.142%5Ev99%5Epc_search_result_base3&utm_term=printf">https://blog.csdn.net/weixin_43519514/article/details/121842805?ops_request_misc=%7B%22request%5Fid%22%3A%22170438093616800222836666%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170438093616800222836666&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-121842805-null-null.142^v99^pc_search_result_base3&amp;utm_term=printf</a>(%d%2C%d\n%2C (%2B%2Bp)-&gt;a%2C (p%2B%2B)-&gt;a))</li>
</ul>
</li>
<li><p>scanf(格式控制字符串，输入参数1，……)</p>
<ul>
<li>格式控制字符串中尽量不要出现普通字符<br>如”%d and %d”输入中须有and存在</li>
</ul>
</li>
<li><p>表达式的值</p>
<ul>
<li>赋值句：返回赋值号左侧变量的最终值（若数组整体赋值返回值为何（<strong>不可以这么干</strong>））</li>
<li>表达式：返回值为表达式结果</li>
</ul>
</li>
<li><p>if语句中判断条件若无关系运算符，则其中<strong>语句等价于：表达式！&#x3D;0</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)&#123;</span><br><span class="line">	语句<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句<span class="number">2</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>测试程序数据<strong>边界条件单独考虑</strong></li>
<li>math.h函数库</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 绝对值函数</span></span><br><span class="line"><span class="type">double</span> result1 = <span class="built_in">fabs</span>(x);  <span class="comment">// 计算 x 的绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 平方根函数</span></span><br><span class="line"><span class="type">double</span> result2 = <span class="built_in">sqrt</span>(x);  <span class="comment">// 计算 x 的平方根</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 幂函数</span></span><br><span class="line"><span class="type">double</span> result3 = <span class="built_in">pow</span>(base, exponent);  <span class="comment">// 计算 base 的 exponent 次幂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 三角函数</span></span><br><span class="line"><span class="type">double</span> result4 = <span class="built_in">sin</span>(angle);  <span class="comment">// 计算 angle（弧度）的正弦值</span></span><br><span class="line"><span class="type">double</span> result5 = <span class="built_in">cos</span>(angle);  <span class="comment">// 计算 angle（弧度）的余弦值</span></span><br><span class="line"><span class="type">double</span> result6 = <span class="built_in">tan</span>(angle);  <span class="comment">// 计算 angle（弧度）的正切值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 指数函数</span></span><br><span class="line"><span class="type">double</span> result7 = <span class="built_in">exp</span>(x);  <span class="comment">// 计算 e 的 x 次幂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 自然对数函数</span></span><br><span class="line"><span class="type">double</span> result8 = <span class="built_in">log</span>(x);  <span class="comment">// 计算 x 的自然对数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 取整函数</span></span><br><span class="line"><span class="type">double</span> result9 = <span class="built_in">floor</span>(x);  <span class="comment">// 计算不大于 x 的最大整数</span></span><br><span class="line"><span class="type">double</span> result10 = <span class="built_in">ceil</span>(x);  <span class="comment">// 计算不小于 x 的最小整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 取最大值和最小值</span></span><br><span class="line"><span class="type">double</span> result11 = fmax(x, y);  <span class="comment">// 返回 x 和 y 中的较大值</span></span><br><span class="line"><span class="type">double</span> result12 = fmin(x, y);  <span class="comment">// 返回 x 和 y 中的较小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 四舍五入函数</span></span><br><span class="line"><span class="type">double</span> result13 = round(x);  <span class="comment">// 返回 x 的四舍五入值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 浮点数取模</span></span><br><span class="line"><span class="type">double</span> result14 = <span class="built_in">fmod</span>(x, y);  <span class="comment">// 返回 x 除以 y 的余数</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li><p>for循环</p>
<ul>
<li>表达式1：为循环变量赋初值</li>
<li>表达式2：循环条件</li>
<li>表达式3：设置步长</li>
<li>循环体语句：<strong>只能是一条语句</strong>，<em><strong>复合语句在语法上被认为是一条语句</strong></em></li>
<li>for循环用于<strong>循环次数已知</strong>的循环时</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>； 表达式<span class="number">2</span>； 表达式<span class="number">3</span>)</span><br><span class="line">	循环体语句；</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-分支结构"><a href="#第三章-分支结构" class="headerlink" title="第三章 分支结构"></a>第三章 分支结构</h2><ol>
<li><p>if else语句：内嵌语句，只允许一条语句</p>
</li>
<li><p>switch语句：</p>
</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	 <span class="keyword">case</span> 常量表达式<span class="number">1</span>：语句段<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> 常量表达式<span class="number">2</span>：语句段<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> 常量表达式<span class="number">3</span>：语句段<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">				……</span><br><span class="line">	 <span class="keyword">case</span> 常量表达式n：语句段n;<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">default</span> :        语句段n+<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有常量表达式的值不能都相等</li>
<li>每个语句段可以包括<strong>一条或多条语句</strong>，也可以为空语句</li>
<li>default可省略（相当于没有else），在C语言中，<code>switch</code>语句是可以没有<code>case</code>部分，只有<code>default</code>部分的。这种情况下，程序就会执行<code>default</code>部分的代码。这种用法通常被称为”空的<code>switch</code>“，它可以用来指示某些特定条件下不需要执行任何操作。</li>
<li>在switch中不用break语句，从第一个符合的case进入，<strong>执行后面所有语句段</strong></li>
<li>无论default放在哪，所有case不进入<strong>都会进入default</strong></li>
</ul>
<ol>
<li>if-else的嵌套：else在花括号以外与<strong>最近的未匹配的if语句</strong>对应</li>
</ol>
<h2 id="第四章-while循环"><a href="#第四章-while循环" class="headerlink" title="第四章 while循环"></a>第四章 while循环</h2><ol>
<li>while语句</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line"> 循环体语句;</span><br></pre></td></tr></table></figure>

<ul>
<li>表达式可以是任意合法语句，循环体语句只能是一条语句</li>
</ul>
<ol>
<li>do-while语句</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"> 循环体语句</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>

<ul>
<li>无论循环条件的值为何，<strong>至少会执行一次循环体</strong></li>
</ul>
<ol start="3">
<li><p>break语句&amp;continue语句</p>
</li>
<li><p>嵌套循环，<strong>内外层循环变量不能相同</strong></p>
</li>
<li><p>贪心算法</p>
<ul>
<li>问题求解过程中只考虑当前局部最优的策略，能否最终得到全局的最优解</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request_id%22:%22170009643116800182714197%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170009643116800182714197&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51336300-null-null.142%5Ev96%5Epc_search_result_base3&utm_term=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">从零开始学贪心算法-CSDN博客</a>（ctrl+点击）</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h2><ol>
<li><p>定义：函数是一个完成特定工作的独立程序模块，包括库函数和自定义函数两种</p>
</li>
<li><p>构成：</p>
</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型 函数名（函数名）			<span class="comment">/*函数首部*/</span></span><br><span class="line">&#123;</span><br><span class="line"> 函数实现过程					<span class="comment">/*函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数首部：函数首部后面不能加分号，<strong>和函数体一起构成完整的函数定义</strong></p>
<ul>
<li>函数类型：<strong>函数结果返回的类型</strong>，若不用返回结果类型为void，默认定义为int</li>
<li>函数名</li>
<li>形参表：各个形参之间用逗号分隔，每个形参前面的类型必须<strong>分别写明</strong></li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>形参vs实参</p>
<ol>
<li>实参：可以是常量、变量和表达式</li>
<li>形参：<strong>只能是变量</strong>，用于接收实参传递来的值</li>
<li>形参和实参必须一一对应，两者数量相同，<strong>类型尽量一致</strong></li>
</ol>
</li>
<li><p>函数的调用：</p>
<ol start="4">
<li>若自定义函数在主调函数之前定义，无需声明</li>
<li>若自定义函数的定义在主调函数之后，须在调用之前加上<strong>函数原型声明</strong><ul>
<li><strong>函数声明是一条C语句</strong>，而函数定义是<strong>函数首部不是语句</strong>，故不能加分号</li>
<li>若函数声明在其他函数内，仅在声明的函数中可调用</li>
<li>若定义后声明不会影响</li>
</ul>
</li>
</ol>
</li>
<li><p>结构化程序设计思想</p>
<ol>
<li>自顶向下分析问题的方法：将大问题拆分</li>
<li>模块化设计：<ol>
<li>一个模块只完成一个特定的功能</li>
<li>模块之间指通过参数进行调用</li>
<li>一个模块只有一个入口和出口</li>
<li>慎用全局变量</li>
</ol>
</li>
<li>原则：<ol>
<li>对变量、函数、常量等命名时，要见名知义</li>
<li>添加必要的注释</li>
<li>良好缩进格式</li>
</ol>
</li>
</ol>
</li>
<li><p>局部变量vs全局变量</p>
<ol start="4">
<li>局部变量：<ol start="4">
<li>定义在函数内部的变量</li>
<li>若在复合语句中定义的变量，作用范围仅限于复合语句</li>
<li>局部变量一般定义在函数或复合语句开始处，<strong>标准C规定不能定义在中间位置</strong></li>
</ol>
</li>
<li>全局变量：<ol start="7">
<li>一般情况下把全局变量定义在程序的最前面</li>
</ol>
</li>
<li>相较：<ul>
<li>二者作用范围不同，故<strong>可同名</strong></li>
<li>同名时：在该函数内<strong>局部变量起作用</strong>，<strong>复合语句中局部变量起作用</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>变量</p>
<ol>
<li>自动变量：函数被调用时自动分配存储空间，auto可忽略</li>
<li>静态变量：生存周期持续到程序结束，static</li>
<li>自动变量若没赋初值，存储单元中将是随机值，静态变量则为1</li>
</ol>
</li>
</ol>
<hr>
<h2 id="第六章-数据类型"><a href="#第六章-数据类型" class="headerlink" title="第六章 数据类型"></a>第六章 数据类型</h2><ol>
<li><p>数据存储：</p>
<ul>
<li>整型数据：<ul>
<li>正数：<ul>
<li><strong>原码、反码和补码相同</strong>：符号位为0，其余为数的二进制表示</li>
</ul>
</li>
<li>负数：<ul>
<li>原码：符号位为1，其余为数的绝对值的二进制表示</li>
<li>反码：符号位为1，其余位取反</li>
<li>补码：符号位为1，对反码加1</li>
</ul>
</li>
<li>整数的加法可以用补码加法直接实现</li>
</ul>
</li>
<li>实数存储：<ul>
<li>分为<strong>符号位、阶码和尾数</strong>三部分</li>
</ul>
</li>
<li>字符型数据存储：<ul>
<li>存储ASCⅡ码</li>
</ul>
</li>
</ul>
</li>
<li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="image-20231116103427030.png" alt="image-20231116103427030"></p>
</li>
<li><p>整型</p>
<ol>
<li><p>整数的表示：</p>
<ul>
<li>十进制：首位数字不能是0</li>
<li>八进制：首位数字必须是0</li>
<li>十六进制：必有前缀0x或0X</li>
</ul>
</li>
<li><p>整数的类型：</p>
<ul>
<li>后缀l或L表示long型常量</li>
<li>后缀u或U表示unsigned型常量</li>
<li>如果整数后面没有出现字母，就根据整型常量的值确定它的类型</li>
</ul>
</li>
<li><p>格式控制说明<a id = "type-ctl"></a></p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>十进制</th>
<th>八进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>%d</td>
<td>%o</td>
<td>%x</td>
</tr>
<tr>
<td>long</td>
<td>%ld</td>
<td>%lo</td>
<td>%lx</td>
</tr>
<tr>
<td>unsigned</td>
<td>%u</td>
<td>%o</td>
<td>%x</td>
</tr>
<tr>
<td>unsigned long</td>
<td>%lu</td>
<td>%lo</td>
<td>%lx</td>
</tr>
</tbody></table>
<ol>
<li><p>无论几进制输出后<strong>省略前缀</strong></p>
</li>
<li><p>字符型</p>
<ol>
<li><p>字符型：</p>
<ul>
<li>在内存中占用一个字节，用于存储ASCⅡ码</li>
<li>因为字符型变量的值可以是字符或整数，<strong>整型变量和字符型变量的定义和值可以互换</strong></li>
</ul>
</li>
<li><p>字符型常量</p>
<ol>
<li><p>ASCⅡ字符集</p>
</li>
<li><p>转义字符：反斜杠加上一个字符或数字组成</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\n</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">横向跳格</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">反斜杠</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center">\ddd</td>
<td align="center">1~3位八进制整数所表示的字符</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td align="center">1~2位十六进制整数所代表的字符</td>
</tr>
</tbody></table>
<ol>
<li>getchar()函数与putchar()函数<ul>
<li>仅能处理单个字符的输入和输出</li>
</ul>
</li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%3c&quot;</span>,&amp;ch);		<span class="comment">/*取输入框3个字符，但ch只存储						其中第一个字符*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ch);		<span class="comment">/*输出第一个字符*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>实型</p>
</li>
<li><p>单精度浮点型&amp;双精度浮点型</p>
</li>
<li><p>实型常量：</p>
<ol>
<li>都是双精度浮点型</li>
<li>浮点表示法：小数</li>
<li>科学计数法：正负号、数字和e（或E）组成</li>
</ol>
</li>
<li><p>格式控制说明：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">数据类型</th>
<th align="center">格式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">printf</td>
<td align="center">float</td>
<td align="center">%f</td>
<td align="center">以小数形式输出浮点数（保留6位小数）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">double</td>
<td align="center">%e</td>
<td align="center">以指数形式输出浮点数（小数点前有且仅有一位非零的数字）</td>
</tr>
<tr>
<td align="center">scanf</td>
<td align="center">float</td>
<td align="center">%f</td>
<td align="center">以小数形式或指数形式输入一个单精度浮点数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">%e</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">double</td>
<td align="center">%lf</td>
<td align="center">以小数形式或指数形式输入一个双精度浮点数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">%le</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li><p>类型转换</p>
</li>
<li><p>自动类型转换</p>
<ol>
<li>非赋值运算：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20231116211606755.png" alt="image-20231116211606755"><ol>
<li>赋值运算的类型转换</li>
</ol>
</li>
</ol>
<ul>
<li>将赋值号<strong>右侧表达式的类型自动转换成赋值号左侧变量类型</strong></li>
<li>若左右类型不同会导致精度的降低</li>
</ul>
</li>
<li><p><strong>强制类型转换</strong></p>
<ol>
<li>强制类型转换并不改变数据的定义</li>
<li>强制类型转换是运算符，<strong>不是函数</strong></li>
</ol>
</li>
<li><p>移位运算</p>
<ol>
<li>实现方式：<ol>
<li>循环移位：移入的位等于移出的位</li>
<li>逻辑移位：移出的位丢失，移入的位取0</li>
<li>算数移位：移出的位丢失，左移入的位取0，右移入的位取符号位</li>
<li><strong>操作数的移位不改变原操作数的值</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="第七章-数组"><a href="#第七章-数组" class="headerlink" title="第七章 数组"></a>第七章 数组</h2><ol>
<li><p>数组（数字）</p>
<ol>
<li><p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 数组名[数组长度]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数组长度须为常量</strong></li>
<li><strong>数组内每个元素具有相同的数据类型</strong></li>
<li>数组名表示该数组所分配连续内存空间中第一个单元的地址，由于数组空间一经分配后，在运行过程中不会改变，因此数组名是一个地址常量，不允许修改</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li><strong>初值表</strong><ul>
<li>对于任意维度数组，初值表若仅包含定义中的部分空间，剩余自动赋0</li>
<li>对于多维度的数组，仅可省略第一个长度</li>
</ul>
</li>
<li>动态数组自动赋随机值，静态数组自动赋0</li>
</ul>
</li>
</ol>
</li>
<li><p>字符串</p>
<ol>
<li><p>用双引号括起来的字符序列，<strong>以’\0’结束</strong></p>
</li>
<li><p>数组长度至少是字符串的有效长度+1</p>
</li>
<li><p>两种输入方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*输入1*/</span></span><br><span class="line"><span class="keyword">while</span>((ch[k]=getchar())!=<span class="string">&#x27;\n&#x27;</span>)&#123;			<span class="comment">/*逐个加入*/</span></span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输入2*/</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>,ch);					<span class="comment">/*直到换行符结束读入*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="动态地址分配操作"><a href="#动态地址分配操作" class="headerlink" title="动态地址分配操作"></a>动态地址分配操作</h3><p>动态地址分配是指程序在运行的过程中，根据需要从操作系统中申请一块内存空间，并在不再需要时归还给操作系统。常见的动态地址分配方式包括 <code>malloc</code>、<code>calloc</code>、<code>realloc</code> 和 <code>free</code> 等操作。</p>
<p>以下是这些操作的说明：</p>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><code>malloc</code></h4><p><code>malloc</code> 函数用于动态分配一块指定大小的内存空间，并返回指向该内存空间的指针。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>size</code> 参数表示需要分配的内存大小（以字节为单位）。如果分配成功，则返回一个指针，指向所分配的内存空间的起始位置；否则，返回空指针 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码示例中，使用 <code>malloc</code> 动态分配了 <code>n</code> 个整数大小的内存空间，并将指针类型强制转换为 <code>int*</code> 类型，以便后续使用。</p>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a><code>calloc</code></h4><p><code>calloc</code> 函数与 <code>malloc</code> 类似，也用于动态分配内存空间，但它可以在分配内存的同时初始化所有位元为零。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>num</code> 表示要分配的元素数量，<code>size</code> 表示每个元素的大小。<code>calloc</code> 函数分配的内存块大小为 <code>num * size</code> 字节，并返回指向该内存块起始位置的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码示例中，使用 <code>calloc</code> 分配了 <code>n</code> 个整数大小的内存空间，并初始化为零。</p>
<h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a><code>realloc</code></h4><p><code>realloc</code> 函数用于重新分配之前已经分配的内存空间，可以扩大或缩小内存空间。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>ptr</code> 参数是之前分配内存时返回的指针，<code>size</code> 表示需要重新分配的内存大小。如果 <code>ptr</code> 是空指针，则 <code>realloc</code> 的功能与 <code>malloc</code> 相同；如果 <code>size</code> 的值为零，则 <code>realloc</code> 的功能与 <code>free</code> 相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码示例中，首先使用 <code>malloc</code> 分配了 <code>n</code> 个整数大小的内存空间，并将指针赋值给变量 <code>p</code>。然后使用 <code>realloc</code> 将 <code>p</code> 所指向的内存空间扩大为 <code>m</code> 个整数大小的内存空间。如果重新分配失败，则返回空指针 <code>NULL</code>。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a><code>free</code></h4><p><code>free</code> 函数用于释放之前已经分配的内存空间。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>ptr</code> 参数是指向之前分配的内存空间的指针。使用 <code>free</code> 函数释放内存空间后，该指针不再有效，不能再使用它来访问已经释放的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态分配的内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<p>上述代码示例中，首先使用 <code>malloc</code> 分配了 <code>n</code> 个整数大小的内存空间，并将指针赋值给变量 <code>p</code>。使用完内存空间后，使用 <code>free</code> 函数释放了内存。</p>
<hr>
<h2 id="第八章-指针"><a href="#第八章-指针" class="headerlink" title="第八章  指针"></a>第八章  指针</h2><h3 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h3><p>对内存单元的表示编号</p>
<h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><ul>
<li><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 *指针变量名；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类型名指定指针变量的类型，指针变量名是指针变量的名称，必须是一个合法的标识符。</p>
</li>
<li><p>指针值可以是特殊地址0，也可以是一个代表机器地址的正整数</p>
</li>
</ul>
</li>
<li><p>不同类型的指针变量所占的<strong>空间相同</strong></p>
</li>
<li><p>特殊指针0或者NULL为空指针，不指向任何单元</p>
</li>
<li><p>指针变量定义后，一般只能指向相同类型的变量</p>
</li>
<li><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4></li>
<li><p>&amp;：</p>
<ul>
<li>取地址</li>
</ul>
</li>
<li><p>*：</p>
<ul>
<li><p>访问指针所指向内容</p>
</li>
<li><h5 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h5><ul>
<li>通过指针中间变量进行访问</li>
<li>直接访问则直接通过变量名访问</li>
<li>间接访问动态性更强，更灵活</li>
</ul>
</li>
<li><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><p>*优先值低于++，故 *p++等价于 *(p++)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>,x,*p;</span><br><span class="line">p=&amp;a;</span><br><span class="line">x=*p++</span><br></pre></td></tr></table></figure>

<p>该代码段运行结果为，将a的值赋值给x，p指向a后一个内存单位</p>
</li>
</ul>
</li>
<li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>可以用初始化了的指针变量给另一个指针变量作初始化值</li>
<li>不能用数值作为指针变量的初值，但可以将一个指针变量初始化为一个空指针</li>
<li>指针如果没有被赋值，其值不确定，指向不确定单元，不可轻易使用</li>
</ul>
</li>
</ul>
<h3 id="数组、指针和地址"><a href="#数组、指针和地址" class="headerlink" title="数组、指针和地址"></a>数组、指针和地址</h3><ul>
<li><p>基地址：内存中存储数组的起始位置</p>
</li>
<li><p>数组名其实为数组的基地址，但与指针不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>],*p</span><br><span class="line">p=a+<span class="number">1</span>;</span><br><span class="line">p=&amp;a[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/*以上两句等价*/</span></span><br><span class="line"><span class="comment">/*p=a+1合法，而a=a+1不合法*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第九章-结构"><a href="#第九章-结构" class="headerlink" title="第九章 结构"></a>第九章 结构</h2><p>结构类型是一种允许程序员把一些数据分量聚合成一个整体的数据类型</p>
<h3 id="定义与初始化："><a href="#定义与初始化：" class="headerlink" title="定义与初始化："></a>定义与初始化：</h3><ul>
<li><p>结构类型是由用户根据需要，按照规定的格式自行定义的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名&#123;</span>					<span class="comment">/*struct为定义结构类型的关键字*/</span></span><br><span class="line">    						  <span class="comment">/*struct与结构名两者合起来共同组成结							    构类型名*/</span></span><br><span class="line">	类型名 结构成员名<span class="number">1</span>;		    <span class="comment">/*结构成员又称结构分量*/</span></span><br><span class="line">	类型名 结构成员名<span class="number">2</span>;</span><br><span class="line">	……</span><br><span class="line">	类型名 结构成员名n;</span><br><span class="line">&#125;;							   <span class="comment">/*定义以分号结束，故视为一条语句*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套定义：</p>
<ul>
<li>在定义嵌套的结构类型时，必须<strong>先定义成员的结构类型</strong>，再定义主结构类型</li>
</ul>
</li>
<li><h4 id="三种定义方式以及初始化："><a href="#三种定义方式以及初始化：" class="headerlink" title="三种定义方式以及初始化："></a>三种定义方式以及初始化：</h4><ol>
<li><p>单独定义</p>
<ul>
<li><p>先定义一个结构类型，再定义这种结构类型的变量</p>
</li>
<li><p>关键字struct和结构名必须联合使用，因为它们<strong>合起来表示一个数据类型名</strong></p>
</li>
</ul>
</li>
<li><p>混合定义</p>
<ul>
<li><p>在定义结构变量时同时定义结构变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名&#123;</span>					</span><br><span class="line">	类型名 结构成员名<span class="number">1</span>;		   </span><br><span class="line">	类型名 结构成员名<span class="number">2</span>;</span><br><span class="line">	……</span><br><span class="line">	类型名 结构成员名n;</span><br><span class="line">&#125;结构变量名表;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无类型名定义</p>
<ul>
<li><p>在定义时省略结构名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>					</span><br><span class="line">	类型名 结构成员名<span class="number">1</span>;		   </span><br><span class="line">	类型名 结构成员名<span class="number">2</span>;</span><br><span class="line">	……</span><br><span class="line">	类型名 结构成员名n;</span><br><span class="line">&#125;结构变量名表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于没有给出结构名，在定义此语句后面无法再定义这个类型的其他结构变量</p>
</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>采用初始化表的方法，大括号内各项数据间用逗号隔开，将大括号内的数据项按<strong>顺序对应地赋给</strong>结构变量内各个成员，并且要求<strong>数据类型一致</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>通常，一个结构类型变量所占的内存空间是<strong>各个成员所占空间之和</strong>。可以用**sizeof(struct stu)<strong>或</strong>sizeof(stu)**计算所需存储空间（假定定义了一个stu）</p>
</li>
</ul>
<h3 id="结构变量的使用"><a href="#结构变量的使用" class="headerlink" title="结构变量的使用"></a>结构变量的使用</h3><ol>
<li><p>引用：</p>
<ol>
<li><p>结构成员操作符“.”来引用结构成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构变量名.结构成员名</span><br></pre></td></tr></table></figure>

<ul>
<li>由于结构成员运算符的优先级属最高级别，一般情况下优先执行</li>
</ul>
</li>
<li><p>。</p>
</li>
</ol>
</li>
<li><p>整体赋值：</p>
<ul>
<li>允许将一个结构变量的值<strong>直接赋给</strong>另一个结构变量（<strong>唯一整体操作方式</strong>）</li>
<li>只有相同结构类型的变量之间可以直接赋值</li>
</ul>
</li>
<li><p>结构变量</p>
<ul>
<li>可以传递多个数据且参数形式较简单</li>
<li>对于成员较多的大型结构，参数传递时多进行的结构数据复制使得效率降低</li>
</ul>
</li>
</ol>
<p>结构数组</p>
<ul>
<li><p>定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构变量名 数组变量名[大小]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化：</p>
<p>初始化格式与二维数组初始化类似</p>
</li>
<li><p>引用：</p>
<p>结构数组名[下标].结构成员名</p>
</li>
</ul>
<p>结构指针</p>
<ul>
<li><p>结构类型的数据往往由多个成员组成，结构指针实际上是<strong>结构变量的首地址</strong></p>
</li>
<li><p>用指针访问结构成员：</p>
<ol>
<li>用*p访问：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*p).num=<span class="number">101</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中(*p)表示的是p指向的结构变量</p>
</li>
<li><p><strong>括号必不可少</strong>（“*”的优先级低于“.”）</p>
</li>
<li><p>若无括号，*p.num等价于*(p.num)</p>
</li>
</ul>
<ol>
<li>用指向运算符-&gt;访问：</li>
</ol>
</li>
</ul>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;num=<span class="number">101</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>两种访问方式结果一致，而在用指针访问时，通常使用<strong>指向运算符-&gt;</strong></li>
</ul>
<hr>
<h2 id="第十章-函数与程序结构"><a href="#第十章-函数与程序结构" class="headerlink" title="第十章 函数与程序结构"></a>第十章 函数与程序结构</h2><h3 id="结构化的项目建构思想"><a href="#结构化的项目建构思想" class="headerlink" title="结构化的项目建构思想"></a>结构化的项目建构思想</h3><ul>
<li>“自顶向下，逐步求精，函数实现”<ul>
<li>先考虑<strong>问题的总体步骤</strong>，后考虑步骤的细节</li>
<li>将大的步骤拆分为子步骤的序列，逐步明晰实现过程</li>
<li>将最终小目标由<strong>函数实现</strong></li>
</ul>
</li>
<li>注意点：<ol>
<li>限制函数长度</li>
<li>避免函数功能间的重复</li>
<li>减少全局变量的使用</li>
</ol>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这里就少些一点了。</p>
<ol>
<li>核心：递归式&amp;递归出口</li>
<li>间接引用自己（like f(x)&#x3D;不啦不啦g(x)，g(x)&#x3D;不啦不啦f(x)，understand?）</li>
</ol>
<h3 id="C语言的编译预处理"><a href="#C语言的编译预处理" class="headerlink" title="C语言的编译预处理"></a>C语言的编译预处理</h3><p>不属于C语言中真正的语句，但增强了C语言的编译功能，改进了C语言程序设计环境，提高编译效率</p>
<ol>
<li><p>文件包含(#include)</p>
<ul>
<li><p>把指定的文件模板内容插入到#include所在的位置，<strong>编译连接</strong>时，系统会将#include指定的文件拼接生成<strong>可执行代码</strong></p>
</li>
<li><p>在程序编译时起作用，把指定的文件模板包含进来，当经过链接生成可执行代码后，include便不再存在，所以<em><strong>include不为真正的C语句</strong></em></p>
</li>
<li><p>文件包含格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;需包含的文件名&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;需包含的文件名&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若用双引号，则编译程序首先到<strong>当前文件工作夹</strong>寻找被包含语句，若无，再到系统include文件夹中查找文件，<em><strong>若为自己编写头文件，须用双引号</strong></em></p>
</li>
<li><p>头文件：</p>
<ul>
<li><p>.h文件</p>
</li>
<li><p>既有系统头文件，也可以<strong>自己编写头文件</strong></p>
</li>
<li><p>ANSI中常见头文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">头文件名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ctype.h</td>
<td align="center">字符处理</td>
</tr>
<tr>
<td align="center">math.h</td>
<td align="center">与数学处理函数有关的说明与定义</td>
</tr>
<tr>
<td align="center">stdio.h</td>
<td align="center">输入输出函数中使用的有关说明与定义</td>
</tr>
<tr>
<td align="center">string.h</td>
<td align="center">字符串函数的有关说明和定义</td>
</tr>
<tr>
<td align="center">stddef.h</td>
<td align="center">定义某些常用内容</td>
</tr>
<tr>
<td align="center">stdlib.h</td>
<td align="center">杂项说明</td>
</tr>
<tr>
<td align="center">time.h</td>
<td align="center">支持系统时间函数</td>
</tr>
</tbody></table>
<ol>
<li><p>宏定义（#define）</p>
<ul>
<li><p><strong>不为真正的C语句</strong></p>
</li>
<li><p>宏名可以按照C语言标识符规定自己定义，常采用<strong>大写字母串</strong></p>
</li>
<li><p>宏名与宏定义字符串间用<strong>空格分隔</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名 宏定义字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>用途：</p>
<ul>
<li>符号常量</li>
<li>简单的函数功能实现</li>
<li>简化多次书写的相同内容</li>
</ul>
</li>
<li><p>带参数宏定义：</p>
<ul>
<li>宏替换：不做计算，<strong>直接替换</strong></li>
</ul>
</li>
</ul>
<ol>
<li><p>条件编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FLAG							<span class="comment">/*条件仅能为宏名*/</span></span></span><br><span class="line">	程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p>更多请见 #指令 部分内容</p>
</li>
</ol>
<h3 id="大程序"><a href="#大程序" class="headerlink" title="大程序"></a>大程序</h3><ul>
<li><p>一个大程序可以由几个程序文件模块组成</p>
</li>
<li><p>每个程序文件模块又可能包含若干个函数</p>
</li>
<li><p>整个程序<strong>只允许有一个main()函数</strong>，包含main()函数的模块叫<strong>主模块</strong></p>
</li>
<li><p>文件模块间通信：</p>
<ol>
<li><p>外部变量</p>
<ul>
<li>全局变量只能在某个模块中定义一次，若其他模块使用，则需通过<strong>外部变量声明</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> 类型名 变量名表;</span><br></pre></td></tr></table></figure>

<pre><code> 只起说明作用，不分配存储单元，对应的存储单元在全局变量定义时分配
</code></pre>
<ol>
<li><p>静态全局变量</p>
<ul>
<li>若只有一个模块，与一般的全局变量作用完全相同</li>
<li>若存在多个模块，则其作用范围仅限于当前文件模块</li>
</ul>
</li>
<li><p>函数与程序模块文件</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> 函数类型 函数名（参数说明表）;</span><br></pre></td></tr></table></figure>

<ul>
<li>一般情况下，extern可省略，编译程序如果在当前文件模块中找不到函数定义体，自动认为该函数是外部函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第十一章-指针进阶"><a href="#第十一章-指针进阶" class="headerlink" title="第十一章 指针进阶"></a>第十一章 指针进阶</h2><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 *数组名[数组长度];				<span class="comment">/*类型名指定数组元素所指向的变量类型*/</span></span><br></pre></td></tr></table></figure>

<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 **变量名;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二维数组的指针形式：</p>
<ul>
<li>数组名a是一个二级指针，a[i]是一个一级指针</li>
<li>需要注意判断等价关系</li>
<li>行地址：二级指针；列地址：一级指针</li>
</ul>
</li>
</ul>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><ul>
<li>源程序经编译和连接后会生成可执行程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C语言程序中，main函数可以有两个参数，用于接收命令行参数</p>
</li>
<li><p>argc接收命令行参数个数（<strong>包括命令</strong>）</p>
</li>
<li><p>argv接收以字符串常量形式存放的命令行参数（<strong>包括命令本身也作为一个参数</strong>）</p>
</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名(*变量名)(参数类型表)；</span><br></pre></td></tr></table></figure>

<ul>
<li>赋值时，该函数必须已定义或声明，且函数返回值的类型和函数指针的类型一致</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*函数指针名)(参数表);</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>这个就不多说了，主要有几点<ol>
<li>每个结点创建的时候要对指针进行动态地址分配</li>
<li>结点不是连续分布，所以不可用++操作</li>
</ol>
</li>
</ul>
<hr>
<h2 id="第十二章-文件"><a href="#第十二章-文件" class="headerlink" title="第十二章 文件"></a>第十二章 文件</h2><h3 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h3><ul>
<li>文件系统功能是操作系统重要功能和组成部分</li>
<li>文件，指驻留在外部介质中的一个有序数据集<ul>
<li><strong>程序文件</strong>：源文件、目标程序文件、可执行程序</li>
<li><strong>数据文件</strong>：输入输出文件</li>
</ul>
</li>
<li>数据种类：<ol>
<li>文本文件：<ul>
<li>以<strong>字符ASCⅡ码值</strong>进行存储与编码的文件</li>
</ul>
</li>
<li>二进制文件：<ul>
<li>存储<strong>二进制数据</strong>的文件</li>
</ul>
</li>
</ol>
</li>
<li>C语言把文件看作<strong>数据流</strong>，并将数据按顺序以一维方式组织存储</li>
</ul>
<h3 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h3><ol>
<li>缓冲文件系统：<ul>
<li>系统在进行文件操作时<strong>自动</strong>为每一个文件分配一块文件内存缓冲区（内存单元）</li>
</ul>
</li>
<li>非缓冲文件系统：<ul>
<li>文件缓冲区不是由系统自动分配，而需要编程者在程序中用C语句实现分配</li>
</ul>
</li>
</ol>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &lt;已有类型名&gt;&lt;新类型名&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>typeof为关键字</p>
</li>
<li><p>已有类型包括C语言中规定的类型和一定义过的自定义类型，新类型名可由一个和多个重新定义的类型名组成</p>
</li>
<li><p>一般要求<strong>重新定义</strong>的类型名用<strong>大写</strong></p>
</li>
<li><p>基本使用方式：</p>
<ol>
<li>写出原有类型定义变量的语句</li>
<li>用新类型名<strong>替换变量名</strong></li>
<li>开头加上typeof</li>
</ol>
</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">short</span> 			level;       <span class="comment">/*缓冲区使用量*/</span></span><br><span class="line">	<span class="type">unsigned</span>        flags;       <span class="comment">/*文件状态标志*/</span></span><br><span class="line">	<span class="type">char</span>            fd;			 <span class="comment">/*文件描述符*/</span></span><br><span class="line">	<span class="type">short</span>           bsize;       <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>   *buffer;     <span class="comment">/*文件缓冲区的首地址*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>   *curp;       <span class="comment">/*指向文件缓存区的工作指针*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>   hold;        <span class="comment">/*其他信息*/</span></span><br><span class="line">	<span class="type">unsigned</span>        istemp;</span><br><span class="line">	<span class="type">short</span>           token;</span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件结构在头文件<strong>stdio.h</strong>中定义</li>
</ul>
<h3 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h3><p>由于文件缓冲区由系统自动分配，并不像数组那样可以通过数组名加下标进行定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件指针是特殊指针，<strong>指向的是文件类型结构</strong>，而FILE结构中curp成员指示文件缓冲区中<strong>数据存取的位置</strong></p>
</li>
<li><p>文件指针不可进行++或*操作，++操作意味着指向下一个FILE结构</p>
</li>
<li><p>文件操作具有<strong>顺序性</strong>特点，前一个数据取出后，下次将顺序取后一个数据</p>
</li>
</ul>
<h3 id="文件控制模块-文件处理步骤"><a href="#文件控制模块-文件处理步骤" class="headerlink" title="文件控制模块&amp;文件处理步骤"></a>文件控制模块&amp;文件处理步骤</h3><ul>
<li>FCB包括：文件属性、文件名、驱动器号、扩展名、文件长度以及文件记录状态等信息</li>
<li>处理步骤：<ol>
<li>定义文件指针</li>
<li>打开文件（此处书本说是指向磁盘文件缓存区，应该是<strong>指向文件类型结构</strong>不会有歧义一点）</li>
<li>文件处理</li>
<li>关闭文件</li>
</ol>
</li>
</ul>
<h3 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h3><p>先粗略的总结一下一些特性的内容以及函数调用的形式：</p>
<ol>
<li>打开文件 fopen()</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;文件打开方式&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件名须指出对哪个具体文件进行操作，一般要指定文件的路径，若不写出路径，则默认与应用程序的当前路径相同。</p>
</li>
<li><p>文件名路径中”\“需用”\\“，因为C说认为”\“是转义符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">文本文件（二进制文件）</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用方式</td>
<td align="center">含义</td>
</tr>
<tr>
<td align="center">“r”(“rb”)</td>
<td align="center">打开文件进行<strong>只读</strong></td>
</tr>
<tr>
<td align="center">“w”(“wb”)</td>
<td align="center">建立<strong>新文件</strong>进行<strong>只写</strong></td>
</tr>
<tr>
<td align="center">“a”(“ab”)</td>
<td align="center">打开文件进行<strong>追加</strong>（我说append就懂了吧）</td>
</tr>
<tr>
<td align="center">“r+”(“rb+”)</td>
<td align="center">打开文件进行<strong>读&#x2F;写</strong></td>
</tr>
<tr>
<td align="center">“w+”(“wb+”)</td>
<td align="center">建立<strong>新文件</strong>进行<strong>读&#x2F;写</strong></td>
</tr>
<tr>
<td align="center">“a+”(“ab+”)</td>
<td align="center">打开文件进行<strong>读&#x2F;写&#x2F;追加</strong></td>
</tr>
</tbody></table>
<ul>
<li><p>文件打开的实质：</p>
<ul>
<li>把磁盘文件与文件缓存区对应起来，并返回<strong>FILE结构地址</strong></li>
<li>exit(0)是系统标准函数，关闭所有打开文件，并终止程序的执行，<strong>参数0表示程序正常结束</strong>，非0参数为异常</li>
</ul>
</li>
<li><p>C语言允许同时打开多文件，不同文件采用不同文件指针指示，但不允许同一个文件关闭前被再次打开</p>
</li>
</ul>
<ol>
<li><p>关闭文件 fclose(文件指针)</p>
<ul>
<li>关闭文件，确保数据<strong>完整写入</strong>文件，同时释放不用的文件缓存区单元</li>
</ul>
</li>
<li><p>文件读写</p>
</li>
</ol>
<hr>
<h2 id="指令"><a href="#指令" class="headerlink" title="#指令"></a>#指令</h2><p>在 C 语言中，# 指令是预处理器指令的一种形式。预处理器指令是在编译源代码之前被处理的指令。# 指令以 # 开头，通常出现在源代码文件的开头或空行之后。</p>
<p>以下是一些常见的 # 指令：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#include <header_file></td>
<td align="center">插入指定的头文件到当前文件中</td>
</tr>
<tr>
<td align="center">#define macro_name value</td>
<td align="center">定义一个宏</td>
</tr>
<tr>
<td align="center">#ifdef macro_name</td>
<td align="center">如果宏已定义，则编译下面的代码</td>
</tr>
<tr>
<td align="center">#ifndef macro_name</td>
<td align="center">如果宏未定义，则编译下面的代码</td>
</tr>
<tr>
<td align="center">#endif</td>
<td align="center">结束一个 #ifdef 或 #ifndef 块</td>
</tr>
<tr>
<td align="center">#if expression</td>
<td align="center">编译下面的代码，如果指定的表达式为真</td>
</tr>
<tr>
<td align="center">#else</td>
<td align="center">当 #ifdef 或 #ifndef 中的宏未定义时，编译下面的代码</td>
</tr>
<tr>
<td align="center">#elif expression</td>
<td align="center">当 #if 中的表达式为假时，如果指定的表达式为真，编译下面的代码</td>
</tr>
<tr>
<td align="center">#undef macro_name</td>
<td align="center">取消已定义的宏</td>
</tr>
</tbody></table>
<p>这些指令可以帮助我们在编译期间执行一些特定的操作，例如包含其他文件、定义宏、编写条件编译代码等。</p>
<hr>
<h2 id="附表：运算符"><a href="#附表：运算符" class="headerlink" title="附表：运算符 "></a>附表：运算符 <a id = "chart"></a></h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">（）</td>
<td align="center">圆括号</td>
<td align="center">初等运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[]</td>
<td align="center">下标</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-&gt;</td>
<td align="center">指针引用结构体成员</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">.</td>
<td align="center">取结构体变量成员</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">！</td>
<td align="center">逻辑非</td>
<td align="center">单目运算符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">~</td>
<td align="center">按位取反</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">+</td>
<td align="center">正好</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-</td>
<td align="center">负号</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">（类型名）</td>
<td align="center">强制类型转换</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">*</td>
<td align="center">取指针内容</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&amp;</td>
<td align="center">取地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">++</td>
<td align="center">自增</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">–</td>
<td align="center">自减</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">sizeof</td>
<td align="center">长度运算符</td>
<td align="center">返回表达式或数据类型的<strong>内存字节数</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*</td>
<td align="center">相乘</td>
<td align="center">算术运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&#x2F;</td>
<td align="center">相除</td>
<td align="center"><strong>两操作数中若存在负数，取整方向不定</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">%</td>
<td align="center">取模</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+</td>
<td align="center">相加</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">-</td>
<td align="center">相减</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">移位运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">关系运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">等于</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;</td>
<td align="center">按位与</td>
<td align="center">位逻辑运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">^</td>
<td align="center">按位异或</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">|</td>
<td align="center">按位或</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑与</td>
<td align="center">逻辑运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">逻辑的真假判断为<strong>是否为0</strong></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">||</td>
<td align="center">逻辑或</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">?&#x3D;</td>
<td align="center">条件运算</td>
<td align="center">三目运算</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">&#x3D;,+&#x3D;,-&#x3D;,*&#x3D;,&#x2F;&#x3D;,%&#x3D;</td>
<td align="center">赋值运算</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">&amp;&#x3D;,^&#x3D;,&gt;&gt;&#x3D;,&lt;&lt;&#x3D;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">,</td>
<td align="center">逗号运算符</td>
<td align="center">整个表达式结果和类型等于<strong>最后一个表达式</strong></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Aprsev.github.io">Aprsev Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/">http://aprsev.github.io/2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://Aprsev.github.io" target="_blank">Aprsev house</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="../../../../tags/C/">C</a><a class="post-meta__tags" href="../../../../tags/programming/">programming</a><a class="post-meta__tags" href="../../../../tags/note/">note</a></div><div class="post-share"><div class="social-share" data-image="C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="../../../02/10/Introduction-of-my-blog/" title="Introduction of my blog"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../../../../pic/cover.png" onerror="onerror=null;src='../../../../img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Introduction of my blog</div></div><div class="info-2"><div class="info-item-1">本网站为Aprsev尝试个人网站搭建测试网站，会投放一定自制笔记…… </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../pic/head.png" onerror="this.onerror=null;this.src='../img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Aprsev Xu</div><div class="author-info-description"></div><div class="site-data"><a href="../archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="../tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="../categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Aprsev"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Aprsev" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="../mailto:aprsev47@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E7%A8%8B%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">C程复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">第一章 什么是C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序设计语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%8D%95%E4%BD%8D"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">语法单位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">C语言特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-if%E5%88%86%E6%AE%B5%E4%B8%8Efor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.</span> <span class="toc-text">第二章 if分段与for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">&#x2F;（除法运算符）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">数据类型要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">不同数据类型处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EF%BC%88%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. %（取模运算符）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A6%81%E6%B1%82-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">数据类型要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">不同数据类型处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">第三章 分支结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.</span> <span class="toc-text">第四章 while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">第五章 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">第六章 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.</span> <span class="toc-text">第七章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.1.</span> <span class="toc-text">动态地址分配操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#calloc"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">calloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#realloc"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">realloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">free</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8C%87%E9%92%88"><span class="toc-number">1.8.</span> <span class="toc-text">第八章  指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">1.8.1.</span> <span class="toc-text">地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">基本运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">1.8.2.2.1.</span> <span class="toc-text">间接访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-number">1.8.2.2.2.</span> <span class="toc-text">注意点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%9C%B0%E5%9D%80"><span class="toc-number">1.8.3.</span> <span class="toc-text">数组、指针和地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">第九章 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">定义与初始化：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">三种定义方式以及初始化：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">结构变量的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.10.</span> <span class="toc-text">第十章 函数与程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BB%BA%E6%9E%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.10.1.</span> <span class="toc-text">结构化的项目建构思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.10.2.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">C语言的编译预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.10.4.</span> <span class="toc-text">大程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6"><span class="toc-number">1.11.</span> <span class="toc-text">第十一章 指针进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">1.11.1.</span> <span class="toc-text">指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.11.2.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.3.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.11.4.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.11.5.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%96%87%E4%BB%B6"><span class="toc-number">1.12.</span> <span class="toc-text">第十二章 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.12.1.</span> <span class="toc-text">文件的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.12.2.</span> <span class="toc-text">缓冲文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.3.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.12.4.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">1.12.5.</span> <span class="toc-text">文件类型指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.12.6.</span> <span class="toc-text">文件控制模块&amp;文件处理步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.7.</span> <span class="toc-text">文件操作函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">1.13.</span> <span class="toc-text">#指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E8%A1%A8%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.14.</span> <span class="toc-text">附表：运算符 </span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="../2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/" title="C程笔记&amp;回顾"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/C.jpg" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="C程笔记&amp;回顾"/></a><div class="content"><a class="title" href="../2025/03/04/C%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%9B%9E%E9%A1%BE/" title="C程笔记&amp;回顾">C程笔记&amp;回顾</a><time datetime="2025-03-04T01:20:06.000Z" title="发表于 2025-03-04 09:20:06">2025-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../2025/02/10/Introduction-of-my-blog/" title="Introduction of my blog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../pic/cover.png" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="Introduction of my blog"/></a><div class="content"><a class="title" href="../2025/02/10/Introduction-of-my-blog/" title="Introduction of my blog">Introduction of my blog</a><time datetime="2025-02-10T07:54:55.000Z" title="发表于 2025-02-10 15:54:55">2025-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../2025/02/10/hello-world/" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../pic/cover.png" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="../2025/02/10/hello-world/" title="Hello World">Hello World</a><time datetime="2025-02-10T05:51:34.047Z" title="发表于 2025-02-10 13:51:34">2025-02-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Aprsev Xu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="../../../../js/utils.js"></script><script src="../../../../js/main.js"></script><script src="../../../../js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>